
    Parte 3. Java-heranca-interfaces-polimorfismo
    
        * polimorfismo
          - Temos polimorfismo quando uma classe extende de outra ou também quando uma classe implementa uma interface.
          
          - Podemos comunicar com um objeto através de tipos de variáveis diferentes. Por exemplo, 
          se existir uma classe Gerente que seja filha de Funcionario, um objeto do tipo Gerente 
          pode ser referenciado com o tipo Funcionario também.

          - Por exemplo, se existir uma classe Gerente que seja filha de Funcionario, um objeto do tipo Gerente pode ser referenciado com o tipo Funcionario também.

        4. Herança e o uso construtores
             A herança possui baixo acoplamento, logo é fácil mudar uma classe mãe sem causar problemas nas classes filhas.
             A herança captura o que é comum e isola aquilo que é diferente entre classes.
            


            * A anotação @Override - Finalidade?
                É usada para sobrescrever o método da classe mãe, indicando que o método original foi alterado.
                https://pt.stackoverflow.com/questions/22913/qual-a-finalidade-da-override
            
         
        5.  Classes abstratas
            Uma classe abstrata representa um conceito, algo abstrato, e o compilador não permite instanciar um objeto dessa classe. 
            Para instanciar é preciso criar primeiro uma classe filha não abstrata.
            Sempre está relacionado com o conceito de herança.
            Classes abstratas são úteis quando queremos utilizar comportamentos e atributos base em classes com comportamentos em comum.
       
            * Método Abastrato
                Trata-se de um método sem corpo, sem implementação.
                Método abstrato define apenas a assinatura (visibilidade, retorno, nome do método e parâmetros).
                Usamos métodos abstratos quando queremos "forçar" que um filho concreto (classe concreta) implemente um método.
                
        6. Interfaces
            É uma classe abstrata com todos os seus métodos abstratos.Não pode ter nada concreto,por exemplo, um atributo.
            Ela é um contrato onde quem assina se responsabiliza por implementar esses métodos (cumprir o contrato)
            Utilizando interfaces temos uma outra forma de conseguir polimorfismo sem herança.
            Com composições e interfaces teremos mais flexibilidade com nosso código, já que não nos prenderemos ao 
            acoplamento que a herança propõe.


    Java Parte 4: Entendendo excecoes 

        4. Checked e Unchecked

          * Existe uma hierarquia grande de classes que representam exceções. Por exemplo, ArithmeticException 
            é filha de RuntimeException, que herda de Exception, que por sua vez é filha da classe mais ancestral 
            das exceções, Throwable. Conhecer bem essa hierarquia significa saber utilizar exceções em sua aplicação.
          
          * Throwable é a classe que precisa ser extendida para que seja possível jogar um objeto na pilha 
            (através da palavra reservada throw)

          * É na classe Throwable que temos praticamente todo o código relacionada às exceções, inclusive getMessage()
            e printStackTrace(). Todo o resto da hierarquia apenas possui algumas sobrecargas de construtores para 
            comunicar mensagens específicas
          
          * A hierarquia iniciada com a classe Throwable é dividida em exceções e erros. Exceções são usadas em 
            códigos de aplicação. Erros são usados exclusivamente pela máquina virtual.

          * Classes que herdam de Error são usadas para comunicar erros na máquina virtual. Desenvolvedores de 
            aplicação não devem criar erros que herdam de Error.

          * StackOverflowError é um erro da máquina virtual para informar que a pilha de execução não tem mais memória.

          * Exceções são separadas em duas grandes categorias: aquelas que são obrigatoriamente verificadas pelo compilador 
            e as que não são verificadas.

          * As primeiras são denominadas checked e são criadas através do pertencimento a uma hieraquia que não passe por 
            RuntimeException.

          * As segundas são as unchecked, e são criadas como descendentes de RuntimeException.
      
      5.  Aplicando exceções
        
          * Exceções -->  Tipo: Checked
            Se você gosta de avisar aquele desenvolvedor que usará a sua classe, para que ele faça um tratamento, 
            pois algumas exceções podem ocorrer, use checked. 
            
          * Exceções -->  Tipo: Unchecked
            Se você acha que não precisa disso e que o desenvolvedor pode fazer o tratamento quando ele achar melhor, 
            use unchecked.

      6. Finally e try with resources
          
          * Exceções - Tipos

            IllegalStateException
              Indica que um objeto possui um estado inválido.

            * IllegalArgumentException
             
              Verificar os valores no construtor da classe
             
              Exemplo: Agencia negativa
                Conta c = new ContaCorrente(-111, 222); //faz sentido? 
             
                Tratamento:
                  if(agencia < 1) {
                   throw new IllegalArgumentException("Agencia inválida");
                  }
    
    5. Java Parte 5: Pacotes e Java.lang

      2. Todos os modificadores de acesso

        Existem 4 níveis de visibilidade (de menor para maior):
          I. private (visível apenas na classe)
          
          II. <<package private>> (visível na classe E em qualquer outro 
          membro do mesmo pacote, podendo ser chamado de default)
          
          III. protected (visível na classe E em qualquer outro membro do 
          mesmo pacote E para qualquer filho)

          IV. public (visível em qualquer pacote)

      3. Distribuição do seu código
      
        3.1 Java Doc 

          * Javadoc é uma documentação para desenvolvedores

            Exemplo: 
                /*
                * javadoc aqui
                */

          * Rota no Eclipse: "Project -> Generate Javadoc".

          * Apenas os membros "públicos" são contemplados no javadoc. Outros membros (não públicos) são considerados 
            detalhes da implementação e não podemos ser utilizados por outras classes.

          * Tag existentes no JavaDoc

            @author (usado na classe ou interface)
            @version (usado na classe ou interface)
            @param (usado no método e construtor)
            @return (usado apenas no método)
            @exception ou @throws (no método ou construtor)
            @see
            @since
            @serial
            @deprecated

        3.2 JAR
          
          * Através de jars podemos facilitar o compartilhamento do nosso código entre equipes.

          * No exclise, cliente com botão esquerdo em cima do projeto, e selecione a opção EXPORT
            Diversas opções de exportação serão exibidas, selecione aquela dentro do grupo java e 
            dentro dele a opção JAR File clicando em "NEXT";
    
      5. Java Parte 5: Pacote e java.lang

        1. Sobrescrita é relacionado com a herança que não é o caso nesse exemplo. 

          Exemplo:
              boolean existe1 = Banco.existeBanco("CAIXA");
              boolean existe2 = Banco.existeBanco(394);
              
          Existem duas versões desse método que variam nos parâmetros, a primeira recebe uma String e a segunda recebe uma valor int.
      
    Java Parte 6: Conhecendo o java.util
  
        Aula 2: Tipo de Referencias
        
        Aula 3: Equals e Mais Listas
        
          LinkedList é uma lista duplamente "linkada".
            - Vantagem:Inserção e remoção performática em qualquer posição, também no início
            - Desvantagem: Acesso mais demorado pelo índice, é preciso pesquisar os elementos
          
          ArrayList representa um array com redimensionamento dinâmico.
            
            - Vantagem: Acesso fácil e performático pelo índice
            - Desvantagem: Elementos precisam ser copiados quando não há mais capacidade (Apos cria um novo array)

        Aula 5: Vector e a interface Collection

          Vector: 
            é threadsafe
            também usa array
            implementa a interface List

          A interface java.util.Collection que é a interface de todas as coleções        

        Aula 6: As classes Wrappers
        
          - Wrappers: São classes que contém funcionalidades e encapsulam a variável de tipo primitivo!
            Permitem que um array de referencia trabalhe com dados primitivos 
            Para cada primitivo existe sua classe especifica. 
            Exemplo: 
              * int    (4 bytes) --> java.lang.Integer
              * double (8 bytes) --> java.lang.Double
              * float  (4 bytes) --> java.lang.Float
              * long   (8 bytes) --> java.lang.Long
              * short  (2 bytes) --> java.lang.Short
              * byte   (1 bytes) --> java.lang.Byte
              * char   (2 bytes) --> java.lang.Character
              * boolean          --> java.lang.Boolean

          - Parsing - é a conversão do String para um tipo específico

            * Integer.parseInt(diaComoTexto) - Devolve um primitivo          
            * Integer.valueOf(diaComoTexto)  - Devolve uma referencia
          
                    
          - O Boxing é a conversão de tipos primitivos em seu respectivo Wrapper correspondente.
              Exemplo:
                Boolean meuBoolean = true; 
                //a conversão é feita de forma automática para o boolean
                Integer meuInteger = 1203; 
                Double meuDouble = 10.20;

          - O Unboxing Conversion é quando você deseja fazer o inverso do boxing, ou seja, deseja converter um objeto para um tipo primitivo.
              Exemplo:
                boolean a = new Boolean(“True”);
                char c = new Character(‘c’);
                byte b = new Byte(“1”);
                float f = new Float(1.0f);
         
        Aula 7: Ordenacao de lista

          * java.util.Comparator: Parâmetro do método sort da lista e da classe Collections.
          * java.lang.Comparable: Usado para definir a ordem natural dos elementos!
          * Ordem Natural: É a ordem definida pelo próprio elemento da lista (Classe)
        

      Aula 8: Classes anônimas e lambdas

        -  Funcion Object: um objeto que criamos para encapsular uma função ou método. 
           As classes anônimas facilitam um pouco a criação desses objetos. 

        - Classe anônima e lambda: É menos custoso criar uma classe, a partir da interface, e já criar o objeto, de forma direta, em unidade.
          Isso significa que, em vez de fazermos isso, que é um processo burocrático.
            
            Exemplo - Classe anônima (Criou um objeto chamado Comparator):  
              lista.sort( new Comparator<Conta>() {
                  public int compare(Conta c1, Conta c2) {
                    return Integer.compare(c1.getNumero(), c2.getNumero());
                  }
                });

            É melhor escrevermos da seguinte forma (lambda):
              lista.sort( (c1, c2) -> Integer.compare(c1.getNumero(), c2.getNumero()) );

        - Exemplo de lambda em lacos (For):

          * For Tradicional

              List<String> nomes = new ArrayList<>();
              nomes.add("Super Mario");
              nomes.add("Yoshi"); 
              nomes.add("Donkey Kong"); 

              for(int i = 0; i < nomes.size(); i++) {
                  System.out.println(nomes.get(i));
              }
          
          * For - lambda (Uma simples chamada em um metodo)

              List<String> nomes = new ArrayList<>();
              nomes.add("Super Mario");
              nomes.add("Yoshi"); 
              nomes.add("Donkey Kong"); 

              nomes.forEach((nome) -> System.out.println(nome));

        - Como posso acessar (iterar) todas essas implementações de maneira uniforme sem saber os detalhes de cada implementação? A resposta está na "caixa de padrões de projeto" e se chama Iterator.
          Uma Iterator é um objeto que possui no mínimo dois métodos: hasNext()e next(). Ou seja, você pode usá-lo para perguntar se existe um próximo elemento e pedir o próximo elemento. 

          * Veja o código para usar o Iterator de uma lista:
 
              List<String> nomes = new ArrayList<>();
              nomes.add("Super Mario");
              nomes.add("Yoshi"); 
              nomes.add("Donkey Kong"); 

              Iterator<String> it = nomes.iterator();

              while(it.hasNext()) {
                System.out.println(it.next());
              }

          * Se você entendeu esse código, você já aprendeu como iterar com filas, conjuntos ou mapas. 
            Veja o uso do Iterator através de um conjunto:
              
              Set<String> nomes = new HashSet<>();
              nomes.add("Super Mario");
              nomes.add("Yoshi"); 
              nomes.add("Donkey Kong"); 

              Iterator<String> it = nomes.iterator();

              while(it.hasNext()) {
                System.out.println(it.next());
              }

  Java parte 7: Trabalhando com java.io

    Aula 1: Leitura com Java.io

      * Leitura do arquivo
          Exemplo:
            FileInputStream fis = new FileInputStream("lorem.txt"); //Entrada do arquivo
            InputStreamReader isr = new InputStreamReader(fis);  // Transformamos byte em caracteres

      * Leitura da Linha do arquivo
          Exemplo:
            BufferedReader br = new BufferedReader(isr);

      * Classes Abstratas e Concretas (Genericas)
          FileInputStream é um InputStream e o InputStreamReader é um Reader. Podemos usar tipos genericos
          Exemplo:
            InputStream fis = new FileInputStream("lorem.txt");
            Reader isr = new InputStreamReader(fis);  
            BufferedReader br = new BufferedReader(isr);

    Aula 2: Escrita com Java.io

      * Escrita do arquivo
          Exemplo:
            FileOutputStream fis = new FileOutputStream("lorem-saida"); //Conexao para o arquivo de saida
            OutputStreamReader isr = new OutpitStreamReader(fis);  // Transformamos byte em caracteres

      * Escrever linha no arquivo
          Exemplo:
            BufferedWriter  bw = new BufferedWriter(osw);;
             bw.write("Teste escrita no arquivo de saida");
             bw.newLine();
             bw.close();

      * Classes Abstratas e Concretas (Genericas)
          FileInputStream é um OutputStream e o OutputStreamReader é um Writer. Podemos usar tipos genericos
          Exemplo:
            OutputStream fos = new FileOutputStream("Lorem-saida"); //Gerar Arquivo
            Writer osw = new OutputStreamWriter(fos); // Transformar caracteres em byte
            BufferedWriter  bw = new BufferedWriter(osw); //Gravar Linha

    Aula 3: FileWriter e PrintStream

      * Java.io.FileWriter
        - Pode ser combinado com outros Writers, como BufferedWriter
        - E usado para escreveer caracteres
        - E usado para estabelecer uma saida com um arquivo

      * System.lineSeparator()
        Gera uma nova linha no arquivo de texto baseado nos caracteres do sistema operacional.
        
      * Classes para estabelecer uma mesma saida
        
        * PrintWriter (possui varios metodos para imprimir qualquer tipo de dados)
          Exemplo:
            PrintWriter out = new PrintWriter("NomeDoArquivo");
            out.println("Escreva o texto aqui");
            out.close();
        
        * PrintStream (Versao 1.0 do Java)
            Exemplo:
              PrintStream out = new PrintStream("NomeDoArquivo");
              out.println("Escreva o texto aqui");
              out.close();

    Aula 4: Usando java.util.scanner 

      * Leitura de arquivos com Scanner  (Usa o File para abrir o arquivo)
          
          Scanner sc = new Scanner(new File("NomeDoArquivo.txt"));

      * Uso de delimitador com Scanner (Metodo para separar o conteudo por um delimitador)
          
          scanner.useDelimiter(",");

      * Formatação de texto e também de números
        
        Para formatar um double e definir 3 casas decimais, precisamos fazer como abaixo:
          String.format("Formatando %06.3dbl", 45.3);
      
      * Definição de Localização para formatar o texto.
          
          Scanner linhaScanner = new Scanner(linha);
          linha.useLocale(Locale.US);

    Aula 5: Encoding e Charsets

      Os encodings são tabelas que transformam cada codepoint em seu caractere específico, dependendo de determinada região.

      * codePointAt()
        Classe String para revelar o codepoint de determinado caractere a partir da posicao da string
      
      * getByte()
        Metodo da classe string utilizado para transformar caractere em byte

      * StandardCharsets do pacote java.io

    Aula 6: Serialização de objetos

      * Serialização
        Transformação do objeto em um fluxo binário

      * Desserialização
        Transformação de um fluxo binário em um objeto

      * SerialVersionUID
        É boa prática colocar o atributo estático serialVersionUID na classe quando queremos serializar um objeto:

          private static final long serialVersionUID = 1L;

        O serialVersionUID define a versão atual da classe e esse valor fica gravado na representação binária do objeto. 
        Cada vez que alteramos algo incompatível na classe, devemos alterar o seu valor. 

      * NotSerializableException
        Caso alguma das classes não implemente a interface Serializable, uma exceção do tipo NotSerializableException será lançada!   

      * transient
        Existe a palavra-chave transient para indicar que o atributo não deve ser serializado
