
    Parte 3. Java-heranca-interfaces-polimorfismo
    
        * polimorfismo
          - Temos polimorfismo quando uma classe extende de outra ou também quando uma classe implementa uma interface.
          
          - Podemos comunicar com um objeto através de tipos de variáveis diferentes. Por exemplo, 
          se existir uma classe Gerente que seja filha de Funcionario, um objeto do tipo Gerente 
          pode ser referenciado com o tipo Funcionario também.

          - Por exemplo, se existir uma classe Gerente que seja filha de Funcionario, um objeto do tipo Gerente pode ser referenciado com o tipo Funcionario também.

        4. Herança e o uso construtores
             A herança possui baixo acoplamento, logo é fácil mudar uma classe mãe sem causar problemas nas classes filhas.
             A herança captura o que é comum e isola aquilo que é diferente entre classes.
            


            * A anotação @Override - Finalidade?
                É usada para sobrescrever o método da classe mãe, indicando que o método original foi alterado.
                https://pt.stackoverflow.com/questions/22913/qual-a-finalidade-da-override
            
         
        5.  Classes abstratas
            Uma classe abstrata representa um conceito, algo abstrato, e o compilador não permite instanciar um objeto dessa classe. 
            Para instanciar é preciso criar primeiro uma classe filha não abstrata.
            Sempre está relacionado com o conceito de herança.
            Classes abstratas são úteis quando queremos utilizar comportamentos e atributos base em classes com comportamentos em comum.
       
            * Método Abastrato
                Trata-se de um método sem corpo, sem implementação.
                Método abstrato define apenas a assinatura (visibilidade, retorno, nome do método e parâmetros).
                Usamos métodos abstratos quando queremos "forçar" que um filho concreto (classe concreta) implemente um método.
                
        6. Interfaces
            É uma classe abstrata com todos os seus métodos abstratos.Não pode ter nada concreto,por exemplo, um atributo.
            Ela é um contrato onde quem assina se responsabiliza por implementar esses métodos (cumprir o contrato)
            Utilizando interfaces temos uma outra forma de conseguir polimorfismo sem herança.
            Com composições e interfaces teremos mais flexibilidade com nosso código, já que não nos prenderemos ao 
            acoplamento que a herança propõe.


    Java Parte 4: Entendendo excecoes 

        4. Checked e Unchecked

            * Existe uma hierarquia grande de classes que representam exceções. Por exemplo, ArithmeticException 
              é filha de RuntimeException, que herda de Exception, que por sua vez é filha da classe mais ancestral 
              das exceções, Throwable. Conhecer bem essa hierarquia significa saber utilizar exceções em sua aplicação.
            
            * Throwable é a classe que precisa ser extendida para que seja possível jogar um objeto na pilha 
               (através da palavra reservada throw)

            * É na classe Throwable que temos praticamente todo o código relacionada às exceções, inclusive getMessage()
              e printStackTrace(). Todo o resto da hierarquia apenas possui algumas sobrecargas de construtores para 
              comunicar mensagens específicas
            
            * A hierarquia iniciada com a classe Throwable é dividida em exceções e erros. Exceções são usadas em 
              códigos de aplicação. Erros são usados exclusivamente pela máquina virtual.

            * Classes que herdam de Error são usadas para comunicar erros na máquina virtual. Desenvolvedores de 
              aplicação não devem criar erros que herdam de Error.

            * StackOverflowError é um erro da máquina virtual para informar que a pilha de execução não tem mais memória.

            * Exceções são separadas em duas grandes categorias: aquelas que são obrigatoriamente verificadas pelo compilador 
              e as que não são verificadas.

            * As primeiras são denominadas checked e são criadas através do pertencimento a uma hieraquia que não passe por 
              RuntimeException.

            * As segundas são as unchecked, e são criadas como descendentes de RuntimeException.



            