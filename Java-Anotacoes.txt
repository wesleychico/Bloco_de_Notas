
    Parte 3. Java-heranca-interfaces-polimorfismo
    
        * polimorfismo
          - Temos polimorfismo quando uma classe extende de outra ou também quando uma classe implementa uma interface.
          
          - Podemos comunicar com um objeto através de tipos de variáveis diferentes. Por exemplo, 
          se existir uma classe Gerente que seja filha de Funcionario, um objeto do tipo Gerente 
          pode ser referenciado com o tipo Funcionario também.

          - Por exemplo, se existir uma classe Gerente que seja filha de Funcionario, um objeto do tipo Gerente pode ser referenciado com o tipo Funcionario também.

        4. Herança e o uso construtores
             A herança possui baixo acoplamento, logo é fácil mudar uma classe mãe sem causar problemas nas classes filhas.
             A herança captura o que é comum e isola aquilo que é diferente entre classes.
            


            * A anotação @Override - Finalidade?
                É usada para sobrescrever o método da classe mãe, indicando que o método original foi alterado.
                https://pt.stackoverflow.com/questions/22913/qual-a-finalidade-da-override
            
         
        5.  Classes abstratas
            Uma classe abstrata representa um conceito, algo abstrato, e o compilador não permite instanciar um objeto dessa classe. 
            Para instanciar é preciso criar primeiro uma classe filha não abstrata.
            Sempre está relacionado com o conceito de herança.
            Classes abstratas são úteis quando queremos utilizar comportamentos e atributos base em classes com comportamentos em comum.
       
            * Método Abastrato
                Trata-se de um método sem corpo, sem implementação.
                Método abstrato define apenas a assinatura (visibilidade, retorno, nome do método e parâmetros).
                Usamos métodos abstratos quando queremos "forçar" que um filho concreto (classe concreta) implemente um método.
                
        6. Interfaces
            É uma classe abstrata com todos os seus métodos abstratos.Não pode ter nada concreto,por exemplo, um atributo.
            Ela é um contrato onde quem assina se responsabiliza por implementar esses métodos (cumprir o contrato)
            Utilizando interfaces temos uma outra forma de conseguir polimorfismo sem herança.
            Com composições e interfaces teremos mais flexibilidade com nosso código, já que não nos prenderemos ao 
            acoplamento que a herança propõe.


    Java Parte 4: Entendendo excecoes 

        4. Checked e Unchecked

          * Existe uma hierarquia grande de classes que representam exceções. Por exemplo, ArithmeticException 
            é filha de RuntimeException, que herda de Exception, que por sua vez é filha da classe mais ancestral 
            das exceções, Throwable. Conhecer bem essa hierarquia significa saber utilizar exceções em sua aplicação.
          
          * Throwable é a classe que precisa ser extendida para que seja possível jogar um objeto na pilha 
            (através da palavra reservada throw)

          * É na classe Throwable que temos praticamente todo o código relacionada às exceções, inclusive getMessage()
            e printStackTrace(). Todo o resto da hierarquia apenas possui algumas sobrecargas de construtores para 
            comunicar mensagens específicas
          
          * A hierarquia iniciada com a classe Throwable é dividida em exceções e erros. Exceções são usadas em 
            códigos de aplicação. Erros são usados exclusivamente pela máquina virtual.

          * Classes que herdam de Error são usadas para comunicar erros na máquina virtual. Desenvolvedores de 
            aplicação não devem criar erros que herdam de Error.

          * StackOverflowError é um erro da máquina virtual para informar que a pilha de execução não tem mais memória.

          * Exceções são separadas em duas grandes categorias: aquelas que são obrigatoriamente verificadas pelo compilador 
            e as que não são verificadas.

          * As primeiras são denominadas checked e são criadas através do pertencimento a uma hieraquia que não passe por 
            RuntimeException.

          * As segundas são as unchecked, e são criadas como descendentes de RuntimeException.
      
      5.  Aplicando exceções
        
          * Exceções -->  Tipo: Checked
            Se você gosta de avisar aquele desenvolvedor que usará a sua classe, para que ele faça um tratamento, 
            pois algumas exceções podem ocorrer, use checked. 
            
          * Exceções -->  Tipo: Unchecked
            Se você acha que não precisa disso e que o desenvolvedor pode fazer o tratamento quando ele achar melhor, 
            use unchecked.

      6. Finally e try with resources
          
          * Exceções - Tipos

            IllegalStateException
              Indica que um objeto possui um estado inválido.

            * IllegalArgumentException
             
              Verificar os valores no construtor da classe
             
              Exemplo: Agencia negativa
                Conta c = new ContaCorrente(-111, 222); //faz sentido? 
             
                Tratamento:
                  if(agencia < 1) {
                   throw new IllegalArgumentException("Agencia inválida");
                  }
    
    5. Java Parte 5: Pacotes e Java.lang

      2. Todos os modificadores de acesso

        Existem 4 níveis de visibilidade (de menor para maior):
          I. private (visível apenas na classe)
          
          II. <<package private>> (visível na classe E em qualquer outro 
          membro do mesmo pacote, podendo ser chamado de default)
          
          III. protected (visível na classe E em qualquer outro membro do 
          mesmo pacote E para qualquer filho)

          IV. public (visível em qualquer pacote)

    3. Distribuição do seu código
    
      3.1 Java Doc 

        * Javadoc é uma documentação para desenvolvedores

          Exemplo: 
              /*
               * javadoc aqui
               */

        * Rota no Eclipse: "Project -> Generate Javadoc".

        * Apenas os membros "públicos" são contemplados no javadoc. Outros membros (não públicos) são considerados 
          detalhes da implementação e não podemos ser utilizados por outras classes.

        * Tag existentes no JavaDoc

          @author (usado na classe ou interface)
          @version (usado na classe ou interface)
          @param (usado no método e construtor)
          @return (usado apenas no método)
          @exception ou @throws (no método ou construtor)
          @see
          @since
          @serial
          @deprecated

      3.2 JAR
        
        * Através de jars podemos facilitar o compartilhamento do nosso código entre equipes.

        * No exclise, cliente com botão esquerdo em cima do projeto, e selecione a opção EXPORT
          Diversas opções de exportação serão exibidas, selecione aquela dentro do grupo java e 
          dentro dele a opção JAR File clicando em "NEXT";
    
    5. Java Parte 5: Pacote e java.lang

      1. Sobrescrita é relacionado com a herança que não é o caso nesse exemplo. 

        Exemplo:
            boolean existe1 = Banco.existeBanco("CAIXA");
            boolean existe2 = Banco.existeBanco(394);
            
        Existem duas versões desse método que variam nos parâmetros, a primeira recebe uma String e a segunda recebe uma valor int.
    
    Java Parte 6: Conhecendo o java.util

        Aula 2: Tipo de Referencias
        
        Aula 3: Equals e Mais Listas
        
          LinkedList é uma lista duplamente "linkada".
            - Vantagem:Inserção e remoção performática em qualquer posição, também no início
            - Desvantagem: Acesso mais demorado pelo índice, é preciso pesquisar os elementos
          
          ArrayList representa um array com redimensionamento dinâmico.
            
            - Vantagem: Acesso fácil e performático pelo índice
            - Desvantagem: Elementos precisam ser copiados quando não há mais capacidade (Apos cria um novo array)

        Aula 5: Vector e a interface Collection

          Vector: 
            é threadsafe
            também usa array
            implementa a interface List

          A interface java.util.Collection que é a interface de todas as coleções        




            